# 5. Dependency Inversion Principle

> 고수준 정책을 구현하는 코드는 저수준 세부 사항을 구현하는 코드에 의존하면 안된다.
> 
- 추상에는 의존하며, 구체에는 의존하면 안된다.
- 구체적이어도,  안정성이 보장된 요소 의존성은 용납된다. ex. String 클래스

## 5-1. 안정된 추상화

### 안정성

- 인터페이스는 구현체보다 안정적이다.
    - 구현체가 변경되어도 인터페이스는 변경되지 않아도 될 수 있으나, 인터페이스가 변경되면 구현체는 거의 변경되어야 한다.
    - 따라서 코드 변경 시, 인터페이스보다 구현체만 수정하도록 노력한다.
- 안정된 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처이다.

### 안정성을 위한 설계규칙

1. 변동성이 큰 구체 클래스를 참조하지 않는다.
    1. 추상 팩토리 사용
2. 변동성이 큰 구체 클래스로부터 파생하지 않는다.
    1. 1번 원칙에서 특히 상속 관계는 변경하기 어려우므로 주의하자는 의미
3. 구체 함수를 오버라이드 하지 않는다.
    1. 구체함수를 오버라이드하면 기존 구체함수의 의존성을 그대로 상속하게 된다.
    2. 차라리 추상함수로 선언하고 구현체에서 각각 구현하자.
4. 구체적이고 변동성이 크다면 절대로 그 이름을 언급하지 않는다.

## 5-2. 팩토리

- 변동성이 큰 객체를 생성하기 위한 패턴

![image](https://github.com/lghihl/CleanCode-Archetecture/assets/75591617/86d22f05-c88b-4465-8dfc-4874b27a063f)

- Application은 구체적인 ConcreteImpl 대신, Service를 사용
    - 사용할 때는 Service 사용
    - 생성할 때는 Service Factory 사용
- 컴포넌트를 추상적 vs 구체적인 성질로 분리한다.(곡선)
    - 코드 의존성은 구체적 → 추상적인 것으로 흐른다.
    - 제어 흐름은 추상적 → 구체적인 것으로 흐른다. (의존성 역전)

### 구체 컴포넌트

![image](https://github.com/lghihl/CleanCode-Archetecture/assets/75591617/d09393bb-ba34-4e4c-a0a5-4ab4bcbd0346)

- Service FactoryImpl → ConcreteImpl는 유일한 구체적인 의존성이다.(DIP 위반)
    - 일반적으로 시스템에서 DIP 위반을 모두 없앨 수는 없다.
    다만, DIP 위반 클래스들을 적은 수의 구체 컴포넌트 내부로 모아 나머지 부분과 분리할 수 있다.
    - 구체 컴포넌트의 대표적인 예시는 main 함수이다.
