# SOLID
- 함수와 데이터 구조를 클래스로 배치하는 방법과 이들을 결합하는 방법에 대한 원칙
- SOLID의 목표
    - 변경에 유연한 설계
    - 이해하기 쉬운 설계
    - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반


# SRP (Single Responsibility Principle)

> 각 모듈은 변경의 이유가 단 하나여야만 한다.

- 메서드, 클래스 수준의 원칙
    - 함수가 반드시 하나의 일만 해야한다는 원칙과는 다르다.
    - 상위 수준에서는 다음 형태로 다시 등장
        - 컴포넌트 수준 → 공통 폐쇄 원칙
        - 아키텍처 수준 → 아키텍처 경계의 생성을 책임지는 변경의 축
- 하나의 모듈은 하나의 액터에 대해서만 책임져야 한다는 의미이다.
- 모듈이란?
    - 함수와 데이터로 응집된 집합

## SRP 위반 징후

### 징후1) 우발적 중복

![image](https://github.com/lghihl/CleanCode-Archetecture/assets/75591617/824f04c7-2fd6-4d7f-b17b-8f4e37d3aa5e)

- Employee라는 하나의 클래스가 3 가지 액터를 책임지고 있다.
→ 한 액터의 변경사항이 나머지 액터들의 동작에도 영향을 준다.

### 징후2) 병합

- 서로 다른 목적으로 동일한 소스파일을 변경하게되는 상황이 발생한다.

**해결방법**

1. 데이터와 메서드를 분리

![image](https://github.com/lghihl/CleanCode-Archetecture/assets/75591617/123dc2a5-f076-4641-9e33-1b5605c5ad0b)

- 액터별로 클래스를 만들고, Employee Data라는 데이터 구조만 공유하게 만든다.
→ 세 클래스가 서로의 존재를 모른 채 동작할 수 있다.
- 개발자가 관리해야하는 객체가 늘어나는 단점 → 퍼사드 패턴으로 보완

2. 퍼사드 패턴

![image](https://github.com/lghihl/CleanCode-Archetecture/assets/75591617/8678b22e-fb29-44cf-97b9-068b65c1fb9c)

- 퍼사드: 나머지 클래스들의 객체를 생성 + 요청된 메서드를 위임하는 역할
    - 외부에서 각 Employee를 직접 사용하지 않고 Employee Facade를 통해 호출
    - 정면, 표면, 허울이라는 사전적 의미
    - 2개 이상의 메서드를 묶어 복잡한 로직을 숨기는 역할ㅇ르 하기도 한다.

![image](https://github.com/lghihl/CleanCode-Archetecture/assets/75591617/88dc4b0d-2c64-49cc-85f2-22ff7688243d)

- 일부 메서드만 퍼사드하는 예시
    - 비즈니스 로직을 데이터와 가까이 배치하기위해서 등 다양한 이유로 위와 같이 활용 가능
